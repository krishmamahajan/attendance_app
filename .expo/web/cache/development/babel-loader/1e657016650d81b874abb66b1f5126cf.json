{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { WordArray, Hasher, X64Word } from \"./core/core.js\";\nvar RHO_OFFSETS = [];\nvar PI_INDEXES = [];\nvar ROUND_CONSTANTS = [];\nvar _x = 1;\nvar _y = 0;\n\nfor (var t = 0; t < 24; t += 1) {\n  RHO_OFFSETS[_x + 5 * _y] = (t + 1) * (t + 2) / 2 % 64;\n  var newX = _y % 5;\n  var newY = (2 * _x + 3 * _y) % 5;\n  _x = newX;\n  _y = newY;\n}\n\nfor (var x = 0; x < 5; x += 1) {\n  for (var y = 0; y < 5; y += 1) {\n    PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;\n  }\n}\n\nvar LFSR = 0x01;\n\nfor (var i = 0; i < 24; i += 1) {\n  var roundConstantMsw = 0;\n  var roundConstantLsw = 0;\n\n  for (var j = 0; j < 7; j += 1) {\n    if (LFSR & 0x01) {\n      var bitPosition = (1 << j) - 1;\n\n      if (bitPosition < 32) {\n        roundConstantLsw ^= 1 << bitPosition;\n      } else {\n          roundConstantMsw ^= 1 << bitPosition - 32;\n        }\n    }\n\n    if (LFSR & 0x80) {\n      LFSR = LFSR << 1 ^ 0x71;\n    } else {\n      LFSR <<= 1;\n    }\n  }\n\n  ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n}\n\nvar T = [];\n\nfor (var _i = 0; _i < 25; _i += 1) {\n  T[_i] = X64Word.create();\n}\n\nexport var SHA3Algo = function (_Hasher) {\n  _inherits(SHA3Algo, _Hasher);\n\n  var _super = _createSuper(SHA3Algo);\n\n  function SHA3Algo(cfg) {\n    _classCallCheck(this, SHA3Algo);\n\n    return _super.call(this, _objectSpread({\n      outputLength: 512\n    }, cfg));\n  }\n\n  _createClass(SHA3Algo, [{\n    key: \"_doReset\",\n    value: function _doReset() {\n      this._state = [];\n      var state = this._state;\n\n      for (var _i2 = 0; _i2 < 25; _i2 += 1) {\n        state[_i2] = new X64Word();\n      }\n\n      this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n    }\n  }, {\n    key: \"_doProcessBlock\",\n    value: function _doProcessBlock(M, offset) {\n      var state = this._state;\n      var nBlockSizeLanes = this.blockSize / 2;\n\n      for (var _i3 = 0; _i3 < nBlockSizeLanes; _i3 += 1) {\n        var M2i = M[offset + 2 * _i3];\n        var M2i1 = M[offset + 2 * _i3 + 1];\n        M2i = (M2i << 8 | M2i >>> 24) & 0x00ff00ff | (M2i << 24 | M2i >>> 8) & 0xff00ff00;\n        M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 0x00ff00ff | (M2i1 << 24 | M2i1 >>> 8) & 0xff00ff00;\n        var lane = state[_i3];\n        lane.high ^= M2i1;\n        lane.low ^= M2i;\n      }\n\n      for (var round = 0; round < 24; round += 1) {\n        for (var _x2 = 0; _x2 < 5; _x2 += 1) {\n          var tMsw = 0;\n          var tLsw = 0;\n\n          for (var _y2 = 0; _y2 < 5; _y2 += 1) {\n            var _lane2 = state[_x2 + 5 * _y2];\n            tMsw ^= _lane2.high;\n            tLsw ^= _lane2.low;\n          }\n\n          var Tx = T[_x2];\n          Tx.high = tMsw;\n          Tx.low = tLsw;\n        }\n\n        for (var _x3 = 0; _x3 < 5; _x3 += 1) {\n          var Tx4 = T[(_x3 + 4) % 5];\n          var Tx1 = T[(_x3 + 1) % 5];\n          var Tx1Msw = Tx1.high;\n          var Tx1Lsw = Tx1.low;\n\n          var _tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);\n\n          var _tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);\n\n          for (var _y3 = 0; _y3 < 5; _y3 += 1) {\n            var _lane3 = state[_x3 + 5 * _y3];\n            _lane3.high ^= _tMsw;\n            _lane3.low ^= _tLsw;\n          }\n        }\n\n        for (var laneIndex = 1; laneIndex < 25; laneIndex += 1) {\n          var _tMsw2 = void 0;\n\n          var _tLsw2 = void 0;\n\n          var _lane4 = state[laneIndex];\n          var laneMsw = _lane4.high;\n          var laneLsw = _lane4.low;\n          var rhoOffset = RHO_OFFSETS[laneIndex];\n\n          if (rhoOffset < 32) {\n            _tMsw2 = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;\n            _tLsw2 = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;\n          } else {\n              _tMsw2 = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;\n              _tLsw2 = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;\n            }\n\n          var TPiLane = T[PI_INDEXES[laneIndex]];\n          TPiLane.high = _tMsw2;\n          TPiLane.low = _tLsw2;\n        }\n\n        var T0 = T[0];\n        var state0 = state[0];\n        T0.high = state0.high;\n        T0.low = state0.low;\n\n        for (var _x4 = 0; _x4 < 5; _x4 += 1) {\n          for (var _y4 = 0; _y4 < 5; _y4 += 1) {\n            var _laneIndex = _x4 + 5 * _y4;\n\n            var _lane5 = state[_laneIndex];\n            var TLane = T[_laneIndex];\n            var Tx1Lane = T[(_x4 + 1) % 5 + 5 * _y4];\n            var Tx2Lane = T[(_x4 + 2) % 5 + 5 * _y4];\n            _lane5.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;\n            _lane5.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;\n          }\n        }\n\n        var _lane = state[0];\n        var roundConstant = ROUND_CONSTANTS[round];\n        _lane.high ^= roundConstant.high;\n        _lane.low ^= roundConstant.low;\n      }\n    }\n  }, {\n    key: \"_doFinalize\",\n    value: function _doFinalize() {\n      var data = this._data;\n      var dataWords = data.words;\n      var nBitsLeft = data.sigBytes * 8;\n      var blockSizeBits = this.blockSize * 32;\n      dataWords[nBitsLeft >>> 5] |= 0x1 << 24 - nBitsLeft % 32;\n      dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 0x80;\n      data.sigBytes = dataWords.length * 4;\n\n      this._process();\n\n      var state = this._state;\n      var outputLengthBytes = this.cfg.outputLength / 8;\n      var outputLengthLanes = outputLengthBytes / 8;\n      var hashWords = [];\n\n      for (var _i4 = 0; _i4 < outputLengthLanes; _i4 += 1) {\n        var lane = state[_i4];\n        var laneMsw = lane.high;\n        var laneLsw = lane.low;\n        laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 0x00ff00ff | (laneMsw << 24 | laneMsw >>> 8) & 0xff00ff00;\n        laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 0x00ff00ff | (laneLsw << 24 | laneLsw >>> 8) & 0xff00ff00;\n        hashWords.push(laneLsw);\n        hashWords.push(laneMsw);\n      }\n\n      return new WordArray(hashWords, outputLengthBytes);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clone = _get(_getPrototypeOf(SHA3Algo.prototype), \"clone\", this).call(this);\n\n      clone._state = this._state.slice(0);\n      var state = clone._state;\n\n      for (var _i5 = 0; _i5 < 25; _i5 += 1) {\n        state[_i5] = state[_i5].clone();\n      }\n\n      return clone;\n    }\n  }]);\n\n  return SHA3Algo;\n}(Hasher);\nexport var SHA3 = Hasher._createHelper(SHA3Algo);\nexport var HmacSHA3 = Hasher._createHmacHelper(SHA3Algo);","map":{"version":3,"sources":["D:/Krishma_other_pc/react-native_attendance_with_navigation-master/node_modules/react-native-hash/JSHash/lib/sha3.js"],"names":["WordArray","Hasher","X64Word","RHO_OFFSETS","PI_INDEXES","ROUND_CONSTANTS","_x","_y","t","newX","newY","x","y","LFSR","i","roundConstantMsw","roundConstantLsw","j","bitPosition","create","T","SHA3Algo","cfg","outputLength","_state","state","blockSize","M","offset","nBlockSizeLanes","M2i","M2i1","lane","high","low","round","tMsw","tLsw","Tx","Tx4","Tx1","Tx1Msw","Tx1Lsw","laneIndex","laneMsw","laneLsw","rhoOffset","TPiLane","T0","state0","TLane","Tx1Lane","Tx2Lane","roundConstant","data","_data","dataWords","words","nBitsLeft","sigBytes","blockSizeBits","Math","ceil","length","_process","outputLengthBytes","outputLengthLanes","hashWords","push","clone","call","slice","SHA3","_createHelper","HmacSHA3","_createHmacHelper"],"mappings":"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","sourcesContent":["/* eslint linebreak-style: [\"error\", \"windows\"] */\r\n\r\nimport {\r\n  WordArray,\r\n  Hasher,\r\n  X64Word,\r\n} from './core/core.js';\r\n\r\n// Constants tables\r\nconst RHO_OFFSETS = [];\r\nconst PI_INDEXES = [];\r\nconst ROUND_CONSTANTS = [];\r\n\r\n// Compute Constants\r\n// Compute rho offset constants\r\nlet _x = 1;\r\nlet _y = 0;\r\nfor (let t = 0; t < 24; t += 1) {\r\n  RHO_OFFSETS[_x + 5 * _y] = ((t + 1) * (t + 2) / 2) % 64;\r\n\r\n  const newX = _y % 5;\r\n  const newY = (2 * _x + 3 * _y) % 5;\r\n  _x = newX;\r\n  _y = newY;\r\n}\r\n\r\n// Compute pi index constants\r\nfor (let x = 0; x < 5; x += 1) {\r\n  for (let y = 0; y < 5; y += 1) {\r\n    PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\r\n  }\r\n}\r\n\r\n// Compute round constants\r\nlet LFSR = 0x01;\r\nfor (let i = 0; i < 24; i += 1) {\r\n  let roundConstantMsw = 0;\r\n  let roundConstantLsw = 0;\r\n\r\n  for (let j = 0; j < 7; j += 1) {\r\n    if (LFSR & 0x01) {\r\n      const bitPosition = (1 << j) - 1;\r\n      if (bitPosition < 32) {\r\n        roundConstantLsw ^= 1 << bitPosition;\r\n      } else /* if (bitPosition >= 32) */ {\r\n        roundConstantMsw ^= 1 << (bitPosition - 32);\r\n      }\r\n    }\r\n\r\n    // Compute next LFSR\r\n    if (LFSR & 0x80) {\r\n      // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\r\n      LFSR = (LFSR << 1) ^ 0x71;\r\n    } else {\r\n      LFSR <<= 1;\r\n    }\r\n  }\r\n\r\n  ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\r\n}\r\n\r\n// Reusable objects for temporary values\r\nconst T = [];\r\nfor (let i = 0; i < 25; i += 1) {\r\n  T[i] = X64Word.create();\r\n}\r\n\r\n/**\r\n * SHA-3 hash algorithm.\r\n */\r\nexport class SHA3Algo extends Hasher {\r\n  constructor(cfg) {\r\n    /**\r\n     * Configuration options.\r\n     *\r\n     * @property {number} outputLength\r\n     *   The desired number of bits in the output hash.\r\n     *   Only values permitted are: 224, 256, 384, 512.\r\n     *   Default: 512\r\n     */\r\n    super({\r\n      outputLength: 512,\r\n      ...cfg,\r\n    });\r\n  }\r\n\r\n  _doReset() {\r\n    this._state = [];\r\n    const state = this._state;\r\n    for (let i = 0; i < 25; i += 1) {\r\n      state[i] = new X64Word();\r\n    }\r\n\r\n    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\r\n  }\r\n\r\n  _doProcessBlock(M, offset) {\r\n    // Shortcuts\r\n    const state = this._state;\r\n    const nBlockSizeLanes = this.blockSize / 2;\r\n\r\n    // Absorb\r\n    for (let i = 0; i < nBlockSizeLanes; i += 1) {\r\n      // Shortcuts\r\n      let M2i = M[offset + 2 * i];\r\n      let M2i1 = M[offset + 2 * i + 1];\r\n\r\n      // Swap endian\r\n      M2i = (((M2i << 8) | (M2i >>> 24)) & 0x00ff00ff)\r\n        | (((M2i << 24) | (M2i >>> 8)) & 0xff00ff00);\r\n      M2i1 = (((M2i1 << 8) | (M2i1 >>> 24)) & 0x00ff00ff)\r\n        | (((M2i1 << 24) | (M2i1 >>> 8)) & 0xff00ff00);\r\n\r\n      // Absorb message into state\r\n      const lane = state[i];\r\n      lane.high ^= M2i1;\r\n      lane.low ^= M2i;\r\n    }\r\n\r\n    // Rounds\r\n    for (let round = 0; round < 24; round += 1) {\r\n      // Theta\r\n      for (let x = 0; x < 5; x += 1) {\r\n        // Mix column lanes\r\n        let tMsw = 0;\r\n        let tLsw = 0;\r\n        for (let y = 0; y < 5; y += 1) {\r\n          const lane = state[x + 5 * y];\r\n          tMsw ^= lane.high;\r\n          tLsw ^= lane.low;\r\n        }\r\n\r\n        // Temporary values\r\n        const Tx = T[x];\r\n        Tx.high = tMsw;\r\n        Tx.low = tLsw;\r\n      }\r\n      for (let x = 0; x < 5; x += 1) {\r\n        // Shortcuts\r\n        const Tx4 = T[(x + 4) % 5];\r\n        const Tx1 = T[(x + 1) % 5];\r\n        const Tx1Msw = Tx1.high;\r\n        const Tx1Lsw = Tx1.low;\r\n\r\n        // Mix surrounding columns\r\n        const tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\r\n        const tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\r\n        for (let y = 0; y < 5; y += 1) {\r\n          const lane = state[x + 5 * y];\r\n          lane.high ^= tMsw;\r\n          lane.low ^= tLsw;\r\n        }\r\n      }\r\n\r\n      // Rho Pi\r\n      for (let laneIndex = 1; laneIndex < 25; laneIndex += 1) {\r\n        let tMsw;\r\n        let tLsw;\r\n\r\n        // Shortcuts\r\n        const lane = state[laneIndex];\r\n        const laneMsw = lane.high;\r\n        const laneLsw = lane.low;\r\n        const rhoOffset = RHO_OFFSETS[laneIndex];\r\n\r\n        // Rotate lanes\r\n        if (rhoOffset < 32) {\r\n          tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\r\n          tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\r\n        } else /* if (rhoOffset >= 32) */ {\r\n          tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\r\n          tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\r\n        }\r\n\r\n        // Transpose lanes\r\n        const TPiLane = T[PI_INDEXES[laneIndex]];\r\n        TPiLane.high = tMsw;\r\n        TPiLane.low = tLsw;\r\n      }\r\n\r\n      // Rho pi at x = y = 0\r\n      const T0 = T[0];\r\n      const state0 = state[0];\r\n      T0.high = state0.high;\r\n      T0.low = state0.low;\r\n\r\n      // Chi\r\n      for (let x = 0; x < 5; x += 1) {\r\n        for (let y = 0; y < 5; y += 1) {\r\n          // Shortcuts\r\n          const laneIndex = x + 5 * y;\r\n          const lane = state[laneIndex];\r\n          const TLane = T[laneIndex];\r\n          const Tx1Lane = T[((x + 1) % 5) + 5 * y];\r\n          const Tx2Lane = T[((x + 2) % 5) + 5 * y];\r\n\r\n          // Mix rows\r\n          lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\r\n          lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);\r\n        }\r\n      }\r\n\r\n      // Iota\r\n      const lane = state[0];\r\n      const roundConstant = ROUND_CONSTANTS[round];\r\n      lane.high ^= roundConstant.high;\r\n      lane.low ^= roundConstant.low;\r\n    }\r\n  }\r\n\r\n  _doFinalize() {\r\n    // Shortcuts\r\n    const data = this._data;\r\n    const dataWords = data.words;\r\n    const nBitsLeft = data.sigBytes * 8;\r\n    const blockSizeBits = this.blockSize * 32;\r\n\r\n    // Add padding\r\n    dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - (nBitsLeft % 32));\r\n    dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\r\n    data.sigBytes = dataWords.length * 4;\r\n\r\n    // Hash final blocks\r\n    this._process();\r\n\r\n    // Shortcuts\r\n    const state = this._state;\r\n    const outputLengthBytes = this.cfg.outputLength / 8;\r\n    const outputLengthLanes = outputLengthBytes / 8;\r\n\r\n    // Squeeze\r\n    const hashWords = [];\r\n    for (let i = 0; i < outputLengthLanes; i += 1) {\r\n      // Shortcuts\r\n      const lane = state[i];\r\n      let laneMsw = lane.high;\r\n      let laneLsw = lane.low;\r\n\r\n      // Swap endian\r\n      laneMsw = (((laneMsw << 8) | (laneMsw >>> 24)) & 0x00ff00ff)\r\n        | (((laneMsw << 24) | (laneMsw >>> 8)) & 0xff00ff00);\r\n      laneLsw = (((laneLsw << 8) | (laneLsw >>> 24)) & 0x00ff00ff)\r\n        | (((laneLsw << 24) | (laneLsw >>> 8)) & 0xff00ff00);\r\n\r\n      // Squeeze state to retrieve hash\r\n      hashWords.push(laneLsw);\r\n      hashWords.push(laneMsw);\r\n    }\r\n\r\n    // Return final computed hash\r\n    return new WordArray(hashWords, outputLengthBytes);\r\n  }\r\n\r\n  clone() {\r\n    const clone = super.clone.call(this);\r\n\r\n    clone._state = this._state.slice(0);\r\n    const state = clone._state;\r\n    for (let i = 0; i < 25; i += 1) {\r\n      state[i] = state[i].clone();\r\n    }\r\n\r\n    return clone;\r\n  }\r\n}\r\n\r\n/**\r\n * Shortcut function to the hasher's object interface.\r\n *\r\n * @param {WordArray|string} message The message to hash.\r\n *\r\n * @return {WordArray} The hash.\r\n *\r\n * @static\r\n *\r\n * @example\r\n *\r\n *     var hash = CryptoJS.SHA3('message');\r\n *     var hash = CryptoJS.SHA3(wordArray);\r\n */\r\nexport const SHA3 = Hasher._createHelper(SHA3Algo);\r\n\r\n/**\r\n * Shortcut function to the HMAC's object interface.\r\n *\r\n * @param {WordArray|string} message The message to hash.\r\n * @param {WordArray|string} key The secret key.\r\n *\r\n * @return {WordArray} The HMAC.\r\n *\r\n * @static\r\n *\r\n * @example\r\n *\r\n *     var hmac = CryptoJS.HmacSHA3(message, key);\r\n */\r\nexport const HmacSHA3 = Hasher._createHmacHelper(SHA3Algo);\r\n"]},"metadata":{},"sourceType":"module"}