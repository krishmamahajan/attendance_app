{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport Base from \"./Base.js\";\nimport WordArray from \"./WordArray.js\";\nimport Utf8 from \"./Utf8.js\";\n\nvar BufferedBlockAlgorithm = function (_Base) {\n  _inherits(BufferedBlockAlgorithm, _Base);\n\n  var _super = _createSuper(BufferedBlockAlgorithm);\n\n  function BufferedBlockAlgorithm() {\n    var _this;\n\n    _classCallCheck(this, BufferedBlockAlgorithm);\n\n    _this = _super.call(this);\n    _this._minBufferSize = 0;\n    return _this;\n  }\n\n  _createClass(BufferedBlockAlgorithm, [{\n    key: \"reset\",\n    value: function reset() {\n      this._data = new WordArray();\n      this._nDataBytes = 0;\n    }\n  }, {\n    key: \"_append\",\n    value: function _append(data) {\n      var m_data = data;\n\n      if (typeof m_data === 'string') {\n        m_data = Utf8.parse(m_data);\n      }\n\n      this._data.concat(m_data);\n\n      this._nDataBytes += m_data.sigBytes;\n    }\n  }, {\n    key: \"_process\",\n    value: function _process(doFlush) {\n      var processedWords;\n      var data = this._data,\n          blockSize = this.blockSize;\n      var dataWords = data.words;\n      var dataSigBytes = data.sigBytes;\n      var blockSizeBytes = blockSize * 4;\n      var nBlocksReady = dataSigBytes / blockSizeBytes;\n\n      if (doFlush) {\n        nBlocksReady = Math.ceil(nBlocksReady);\n      } else {\n        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n      }\n\n      var nWordsReady = nBlocksReady * blockSize;\n      var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n      if (nWordsReady) {\n        for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n          this._doProcessBlock(dataWords, offset);\n        }\n\n        processedWords = dataWords.splice(0, nWordsReady);\n        data.sigBytes -= nBytesReady;\n      }\n\n      return new WordArray(processedWords, nBytesReady);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clone = _get(_getPrototypeOf(BufferedBlockAlgorithm.prototype), \"clone\", this).call(this);\n\n      clone._data = this._data.clone();\n      return clone;\n    }\n  }]);\n\n  return BufferedBlockAlgorithm;\n}(Base);\n\nexport { BufferedBlockAlgorithm as default };","map":{"version":3,"sources":["D:/Krishma_other_pc/react-native_attendance_with_navigation-master/node_modules/react-native-hash/JSHash/lib/core/BufferedBlockAlgorithm.js"],"names":["Base","WordArray","Utf8","BufferedBlockAlgorithm","_minBufferSize","_data","_nDataBytes","data","m_data","parse","concat","sigBytes","doFlush","processedWords","blockSize","dataWords","words","dataSigBytes","blockSizeBytes","nBlocksReady","Math","ceil","max","nWordsReady","nBytesReady","min","offset","_doProcessBlock","splice","clone","call"],"mappings":";;;;;;;;;;;AAIA,OAAOA,IAAP;AACA,OAAOC,SAAP;AACA,OAAOC,IAAP;;IAWqBC,sB;;;;;AACnB,oCAAc;AAAA;;AAAA;;AACZ;AACA,UAAKC,cAAL,GAAsB,CAAtB;AAFY;AAGb;;;;4BASO;AAEN,WAAKC,KAAL,GAAa,IAAIJ,SAAJ,EAAb;AACA,WAAKK,WAAL,GAAmB,CAAnB;AACD;;;4BAcOC,I,EAAM;AACZ,UAAIC,MAAM,GAAGD,IAAb;;AAGA,UAAI,OAAOC,MAAP,KAAkB,QAAtB,EAAgC;AAC9BA,QAAAA,MAAM,GAAGN,IAAI,CAACO,KAAL,CAAWD,MAAX,CAAT;AACD;;AAGD,WAAKH,KAAL,CAAWK,MAAX,CAAkBF,MAAlB;;AACA,WAAKF,WAAL,IAAoBE,MAAM,CAACG,QAA3B;AACD;;;6BAgBQC,O,EAAS;AAChB,UAAIC,cAAJ;AADgB,UAIDN,IAJC,GAImB,IAJnB,CAIRF,KAJQ;AAAA,UAIKS,SAJL,GAImB,IAJnB,CAIKA,SAJL;AAKhB,UAAMC,SAAS,GAAGR,IAAI,CAACS,KAAvB;AACA,UAAMC,YAAY,GAAGV,IAAI,CAACI,QAA1B;AACA,UAAMO,cAAc,GAAGJ,SAAS,GAAG,CAAnC;AAGA,UAAIK,YAAY,GAAGF,YAAY,GAAGC,cAAlC;;AACA,UAAIN,OAAJ,EAAa;AAEXO,QAAAA,YAAY,GAAGC,IAAI,CAACC,IAAL,CAAUF,YAAV,CAAf;AACD,OAHD,MAGO;AAGLA,QAAAA,YAAY,GAAGC,IAAI,CAACE,GAAL,CAAS,CAACH,YAAY,GAAG,CAAhB,IAAqB,KAAKf,cAAnC,EAAmD,CAAnD,CAAf;AACD;;AAGD,UAAMmB,WAAW,GAAGJ,YAAY,GAAGL,SAAnC;AAGA,UAAMU,WAAW,GAAGJ,IAAI,CAACK,GAAL,CAASF,WAAW,GAAG,CAAvB,EAA0BN,YAA1B,CAApB;;AAGA,UAAIM,WAAJ,EAAiB;AACf,aAAK,IAAIG,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAGH,WAA9B,EAA2CG,MAAM,IAAIZ,SAArD,EAAgE;AAE9D,eAAKa,eAAL,CAAqBZ,SAArB,EAAgCW,MAAhC;AACD;;AAGDb,QAAAA,cAAc,GAAGE,SAAS,CAACa,MAAV,CAAiB,CAAjB,EAAoBL,WAApB,CAAjB;AACAhB,QAAAA,IAAI,CAACI,QAAL,IAAiBa,WAAjB;AACD;;AAGD,aAAO,IAAIvB,SAAJ,CAAcY,cAAd,EAA8BW,WAA9B,CAAP;AACD;;;4BAWO;AACN,UAAMK,KAAK,GAAG,uEAAYC,IAAZ,CAAiB,IAAjB,CAAd;;AACAD,MAAAA,KAAK,CAACxB,KAAN,GAAc,KAAKA,KAAL,CAAWwB,KAAX,EAAd;AAEA,aAAOA,KAAP;AACD;;;;EAlHiD7B,I;;SAA/BG,sB","sourcesContent":["\r\n/* eslint linebreak-style: [\"error\", \"windows\"] */\r\n/* eslint-disable no-use-before-define */\r\n\r\nimport Base from './Base.js';\r\nimport WordArray from './WordArray.js';\r\nimport Utf8 from './Utf8.js';\r\n\r\n/**\r\n * Abstract buffered block algorithm template.\r\n *\r\n * The property blockSize must be implemented in a concrete subtype.\r\n *\r\n * @property {number} _minBufferSize\r\n *\r\n *     The number of blocks that should be kept unprocessed in the buffer. Default: 0\r\n */\r\nexport default class BufferedBlockAlgorithm extends Base {\r\n  constructor() {\r\n    super();\r\n    this._minBufferSize = 0;\r\n  }\r\n\r\n  /**\r\n     * Resets this block algorithm's data buffer to its initial state.\r\n     *\r\n     * @example\r\n     *\r\n     *     bufferedBlockAlgorithm.reset();\r\n     */\r\n  reset() {\r\n    // Initial values\r\n    this._data = new WordArray();\r\n    this._nDataBytes = 0;\r\n  }\r\n\r\n  /**\r\n     * Adds new data to this block algorithm's buffer.\r\n     *\r\n     * @param {WordArray|string} data\r\n     *\r\n     *     The data to append. Strings are converted to a WordArray using UTF-8.\r\n     *\r\n     * @example\r\n     *\r\n     *     bufferedBlockAlgorithm._append('data');\r\n     *     bufferedBlockAlgorithm._append(wordArray);\r\n     */\r\n  _append(data) {\r\n    let m_data = data;\r\n\r\n    // Convert string to WordArray, else assume WordArray already\r\n    if (typeof m_data === 'string') {\r\n      m_data = Utf8.parse(m_data);\r\n    }\r\n\r\n    // Append\r\n    this._data.concat(m_data);\r\n    this._nDataBytes += m_data.sigBytes;\r\n  }\r\n\r\n  /**\r\n     * Processes available data blocks.\r\n     *\r\n     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\r\n     *\r\n     * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\r\n     *\r\n     * @return {WordArray} The processed data.\r\n     *\r\n     * @example\r\n     *\r\n     *     var processedData = bufferedBlockAlgorithm._process();\r\n     *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\r\n     */\r\n  _process(doFlush) {\r\n    let processedWords;\r\n\r\n    // Shortcuts\r\n    const { _data: data, blockSize } = this;\r\n    const dataWords = data.words;\r\n    const dataSigBytes = data.sigBytes;\r\n    const blockSizeBytes = blockSize * 4;\r\n\r\n    // Count blocks ready\r\n    let nBlocksReady = dataSigBytes / blockSizeBytes;\r\n    if (doFlush) {\r\n      // Round up to include partial blocks\r\n      nBlocksReady = Math.ceil(nBlocksReady);\r\n    } else {\r\n      // Round down to include only full blocks,\r\n      // less the number of blocks that must remain in the buffer\r\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\r\n    }\r\n\r\n    // Count words ready\r\n    const nWordsReady = nBlocksReady * blockSize;\r\n\r\n    // Count bytes ready\r\n    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\r\n\r\n    // Process blocks\r\n    if (nWordsReady) {\r\n      for (let offset = 0; offset < nWordsReady; offset += blockSize) {\r\n        // Perform concrete-algorithm logic\r\n        this._doProcessBlock(dataWords, offset);\r\n      }\r\n\r\n      // Remove processed words\r\n      processedWords = dataWords.splice(0, nWordsReady);\r\n      data.sigBytes -= nBytesReady;\r\n    }\r\n\r\n    // Return processed words\r\n    return new WordArray(processedWords, nBytesReady);\r\n  }\r\n\r\n  /**\r\n     * Creates a copy of this object.\r\n     *\r\n     * @return {Object} The clone.\r\n     *\r\n     * @example\r\n     *\r\n     *     var clone = bufferedBlockAlgorithm.clone();\r\n     */\r\n  clone() {\r\n    const clone = super.clone.call(this);\r\n    clone._data = this._data.clone();\r\n\r\n    return clone;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}