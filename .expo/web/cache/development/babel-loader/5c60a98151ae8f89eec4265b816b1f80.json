{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport Base from \"./Base.js\";\nimport Utf8 from \"./Utf8.js\";\n\nvar HMAC = function (_Base) {\n  _inherits(HMAC, _Base);\n\n  var _super = _createSuper(HMAC);\n\n  function HMAC(SubHasher, key) {\n    var _this;\n\n    _classCallCheck(this, HMAC);\n\n    _this = _super.call(this);\n    var hasher = new SubHasher();\n    _this._hasher = hasher;\n    var _key = key;\n\n    if (typeof _key === 'string') {\n      _key = Utf8.parse(_key);\n    }\n\n    var hasherBlockSize = hasher.blockSize;\n    var hasherBlockSizeBytes = hasherBlockSize * 4;\n\n    if (_key.sigBytes > hasherBlockSizeBytes) {\n      _key = hasher.finalize(key);\n    }\n\n    _key.clamp();\n\n    var oKey = _key.clone();\n\n    _this._oKey = oKey;\n\n    var iKey = _key.clone();\n\n    _this._iKey = iKey;\n    var oKeyWords = oKey.words;\n    var iKeyWords = iKey.words;\n\n    for (var i = 0; i < hasherBlockSize; i += 1) {\n      oKeyWords[i] ^= 0x5c5c5c5c;\n      iKeyWords[i] ^= 0x36363636;\n    }\n\n    oKey.sigBytes = hasherBlockSizeBytes;\n    iKey.sigBytes = hasherBlockSizeBytes;\n\n    _this.reset();\n\n    return _this;\n  }\n\n  _createClass(HMAC, [{\n    key: \"reset\",\n    value: function reset() {\n      var hasher = this._hasher;\n      hasher.reset();\n      hasher.update(this._iKey);\n    }\n  }, {\n    key: \"update\",\n    value: function update(messageUpdate) {\n      this._hasher.update(messageUpdate);\n\n      return this;\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize(messageUpdate) {\n      var hasher = this._hasher;\n      var innerHash = hasher.finalize(messageUpdate);\n      hasher.reset();\n      var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n      return hmac;\n    }\n  }]);\n\n  return HMAC;\n}(Base);\n\nexport { HMAC as default };","map":{"version":3,"sources":["D:/Krishma_other_pc/react-native_attendance_with_navigation-master/node_modules/react-native-hash/JSHash/lib/core/HMAC.js"],"names":["Base","Utf8","HMAC","SubHasher","key","hasher","_hasher","_key","parse","hasherBlockSize","blockSize","hasherBlockSizeBytes","sigBytes","finalize","clamp","oKey","clone","_oKey","iKey","_iKey","oKeyWords","words","iKeyWords","i","reset","update","messageUpdate","innerHash","hmac","concat"],"mappings":";;;;;;;;;;AAGA,OAAOA,IAAP;AACA,OAAOC,IAAP;;IAKqBC,I;;;;;AAWnB,gBAAYC,SAAZ,EAAuBC,GAAvB,EAA4B;AAAA;;AAAA;;AAC1B;AAEA,QAAMC,MAAM,GAAG,IAAIF,SAAJ,EAAf;AACA,UAAKG,OAAL,GAAeD,MAAf;AAGA,QAAIE,IAAI,GAAGH,GAAX;;AACA,QAAI,OAAOG,IAAP,KAAgB,QAApB,EAA8B;AAC5BA,MAAAA,IAAI,GAAGN,IAAI,CAACO,KAAL,CAAWD,IAAX,CAAP;AACD;;AAGD,QAAME,eAAe,GAAGJ,MAAM,CAACK,SAA/B;AACA,QAAMC,oBAAoB,GAAGF,eAAe,GAAG,CAA/C;;AAGA,QAAIF,IAAI,CAACK,QAAL,GAAgBD,oBAApB,EAA0C;AACxCJ,MAAAA,IAAI,GAAGF,MAAM,CAACQ,QAAP,CAAgBT,GAAhB,CAAP;AACD;;AAGDG,IAAAA,IAAI,CAACO,KAAL;;AAGA,QAAMC,IAAI,GAAGR,IAAI,CAACS,KAAL,EAAb;;AACA,UAAKC,KAAL,GAAaF,IAAb;;AACA,QAAMG,IAAI,GAAGX,IAAI,CAACS,KAAL,EAAb;;AACA,UAAKG,KAAL,GAAaD,IAAb;AAGA,QAAME,SAAS,GAAGL,IAAI,CAACM,KAAvB;AACA,QAAMC,SAAS,GAAGJ,IAAI,CAACG,KAAvB;;AAGA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,eAApB,EAAqCc,CAAC,IAAI,CAA1C,EAA6C;AAC3CH,MAAAA,SAAS,CAACG,CAAD,CAAT,IAAgB,UAAhB;AACAD,MAAAA,SAAS,CAACC,CAAD,CAAT,IAAgB,UAAhB;AACD;;AACDR,IAAAA,IAAI,CAACH,QAAL,GAAgBD,oBAAhB;AACAO,IAAAA,IAAI,CAACN,QAAL,GAAgBD,oBAAhB;;AAGA,UAAKa,KAAL;;AA3C0B;AA4C3B;;;;4BASO;AAEN,UAAMnB,MAAM,GAAG,KAAKC,OAApB;AAGAD,MAAAA,MAAM,CAACmB,KAAP;AACAnB,MAAAA,MAAM,CAACoB,MAAP,CAAc,KAAKN,KAAnB;AACD;;;2BAcMO,a,EAAe;AACpB,WAAKpB,OAAL,CAAamB,MAAb,CAAoBC,aAApB;;AAGA,aAAO,IAAP;AACD;;;6BAgBQA,a,EAAe;AAEtB,UAAMrB,MAAM,GAAG,KAAKC,OAApB;AAGA,UAAMqB,SAAS,GAAGtB,MAAM,CAACQ,QAAP,CAAgBa,aAAhB,CAAlB;AACArB,MAAAA,MAAM,CAACmB,KAAP;AACA,UAAMI,IAAI,GAAGvB,MAAM,CAACQ,QAAP,CAAgB,KAAKI,KAAL,CAAWD,KAAX,GAAmBa,MAAnB,CAA0BF,SAA1B,CAAhB,CAAb;AAEA,aAAOC,IAAP;AACD;;;;EApH+B5B,I;;SAAbE,I","sourcesContent":["/* eslint linebreak-style: [\"error\", \"windows\"] */\r\n/* eslint-disable no-use-before-define */\r\n\r\nimport Base from './Base.js';\r\nimport Utf8 from './Utf8.js';\r\n\r\n/**\r\n * HMAC algorithm.\r\n */\r\nexport default class HMAC extends Base {\r\n  /**\r\n     * Initializes a newly created HMAC.\r\n     *\r\n     * @param {Hasher} SubHasher The hash algorithm to use.\r\n     * @param {WordArray|string} key The secret key.\r\n     *\r\n     * @example\r\n     *\r\n     *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\r\n     */\r\n  constructor(SubHasher, key) {\r\n    super();\r\n\r\n    const hasher = new SubHasher();\r\n    this._hasher = hasher;\r\n\r\n    // Convert string to WordArray, else assume WordArray already\r\n    let _key = key;\r\n    if (typeof _key === 'string') {\r\n      _key = Utf8.parse(_key);\r\n    }\r\n\r\n    // Shortcuts\r\n    const hasherBlockSize = hasher.blockSize;\r\n    const hasherBlockSizeBytes = hasherBlockSize * 4;\r\n\r\n    // Allow arbitrary length keys\r\n    if (_key.sigBytes > hasherBlockSizeBytes) {\r\n      _key = hasher.finalize(key);\r\n    }\r\n\r\n    // Clamp excess bits\r\n    _key.clamp();\r\n\r\n    // Clone key for inner and outer pads\r\n    const oKey = _key.clone();\r\n    this._oKey = oKey;\r\n    const iKey = _key.clone();\r\n    this._iKey = iKey;\r\n\r\n    // Shortcuts\r\n    const oKeyWords = oKey.words;\r\n    const iKeyWords = iKey.words;\r\n\r\n    // XOR keys with pad constants\r\n    for (let i = 0; i < hasherBlockSize; i += 1) {\r\n      oKeyWords[i] ^= 0x5c5c5c5c;\r\n      iKeyWords[i] ^= 0x36363636;\r\n    }\r\n    oKey.sigBytes = hasherBlockSizeBytes;\r\n    iKey.sigBytes = hasherBlockSizeBytes;\r\n\r\n    // Set initial values\r\n    this.reset();\r\n  }\r\n\r\n  /**\r\n     * Resets this HMAC to its initial state.\r\n     *\r\n     * @example\r\n     *\r\n     *     hmacHasher.reset();\r\n     */\r\n  reset() {\r\n    // Shortcut\r\n    const hasher = this._hasher;\r\n\r\n    // Reset\r\n    hasher.reset();\r\n    hasher.update(this._iKey);\r\n  }\r\n\r\n  /**\r\n     * Updates this HMAC with a message.\r\n     *\r\n     * @param {WordArray|string} messageUpdate The message to append.\r\n     *\r\n     * @return {HMAC} This HMAC instance.\r\n     *\r\n     * @example\r\n     *\r\n     *     hmacHasher.update('message');\r\n     *     hmacHasher.update(wordArray);\r\n     */\r\n  update(messageUpdate) {\r\n    this._hasher.update(messageUpdate);\r\n\r\n    // Chainable\r\n    return this;\r\n  }\r\n\r\n  /**\r\n     * Finalizes the HMAC computation.\r\n     * Note that the finalize operation is effectively a destructive, read-once operation.\r\n     *\r\n     * @param {WordArray|string} messageUpdate (Optional) A final message update.\r\n     *\r\n     * @return {WordArray} The HMAC.\r\n     *\r\n     * @example\r\n     *\r\n     *     var hmac = hmacHasher.finalize();\r\n     *     var hmac = hmacHasher.finalize('message');\r\n     *     var hmac = hmacHasher.finalize(wordArray);\r\n     */\r\n  finalize(messageUpdate) {\r\n    // Shortcut\r\n    const hasher = this._hasher;\r\n\r\n    // Compute HMAC\r\n    const innerHash = hasher.finalize(messageUpdate);\r\n    hasher.reset();\r\n    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\r\n\r\n    return hmac;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}